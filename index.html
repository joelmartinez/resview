<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>ResView</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <!-- Include Three.js via CDN -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    

    class Resource {
      constructor(id, name, position, textureUrl, scene, renderer) {
        this.id = id;
        this.name = name;
        this.position = position;
        this.textureUrl = textureUrl;
        this.scene = scene;
        this.renderer = renderer;
        this.object = null;
      }

      load() {
        return new Promise((resolve, reject) => {
          const textureLoader = new THREE.TextureLoader();
          textureLoader.load(
            this.textureUrl,
            (texture) => {
              // Optional: Adjust texture settings
              texture.minFilter = THREE.LinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();

              const geometry = new THREE.BoxGeometry(1, 1, 1);

              // Create outer cube with texture
              const entityMaterial = new THREE.MeshBasicMaterial({
                map: texture,
                color: 0xffffff, // Set base color to white
                transparent: true, // Enable transparency
                alphaTest: 0.5
              });
              const cube = new THREE.Mesh(geometry, entityMaterial);
              cube.position.set(this.position.x, this.position.y, this.position.z);
              this.scene.add(cube);

              // Create inner cube with white color, slightly smaller
              const innerGeometry = new THREE.BoxGeometry(0.98, 0.98, 0.98); // Slightly smaller
              const innerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
              const innerCube = new THREE.Mesh(innerGeometry, innerMaterial);
              innerCube.position.copy(cube.position);
              this.scene.add(innerCube);

              // Create edges for the outer cube
              const edges = new THREE.EdgesGeometry(geometry);
              const edgesMaterial = new THREE.LineBasicMaterial({
                color: 0x000000,
                depthTest: true,
                depthWrite: true,
                transparent: false,
                side: THREE.FrontSide
              });
              const edgesMesh = new THREE.LineSegments(edges, edgesMaterial);
              edgesMesh.position.copy(cube.position);
              this.scene.add(edgesMesh);

              this.object = cube;
              resolve();
            },
            undefined,
            (err) => {
              console.error('An error occurred loading the texture:', err);
              reject(err);
            }
          );
        });
      }
    }

    class DashedLine {
      constructor(resourceA, resourceB, scene) {
        this.resourceA = resourceA;
        this.resourceB = resourceB;
        this.scene = scene;
      }

      create() {
        const pointA = this.resourceA.object.position.clone();
        const pointB = this.resourceB.object.position.clone();

        const dashSize = 0.2; // Length of each dash
        const gapSize = 0.1; // Length of each gap
        const radius = 0.05; // Thickness of the line
        const material = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Red color

        const dashedLine = this.createDashedLineBetweenPoints(pointA, pointB, dashSize, gapSize, radius, material);
        this.scene.add(dashedLine);
      }

      createDashedLineBetweenPoints(pointA, pointB, dashSize, gapSize, radius, material) {
        const direction = new THREE.Vector3().subVectors(pointB, pointA);
        const totalLength = direction.length();
        direction.normalize();

        const dashedCylinders = new THREE.Group();

        let currentLength = 0;

        while (currentLength < totalLength) {
          const startLength = currentLength;
          const endLength = Math.min(currentLength + dashSize, totalLength);

          const startPoint = new THREE.Vector3().addVectors(pointA, direction.clone().multiplyScalar(startLength));
          const endPoint = new THREE.Vector3().addVectors(pointA, direction.clone().multiplyScalar(endLength));

          const segmentLength = endPoint.distanceTo(startPoint);

          if (segmentLength > 0) {
            const midPoint = new THREE.Vector3().addVectors(startPoint, endPoint).multiplyScalar(0.5);
            const orientation = new THREE.Matrix4();
            orientation.lookAt(startPoint, endPoint, new THREE.Object3D().up);
            orientation.multiply(new THREE.Matrix4().makeRotationX(Math.PI / 2));

            const cylinderGeometry = new THREE.CylinderGeometry(radius, radius, segmentLength, 8, 1, false);
            const cylinder = new THREE.Mesh(cylinderGeometry, material);
            cylinder.applyMatrix4(orientation);
            cylinder.position.copy(midPoint);

            dashedCylinders.add(cylinder);
          }

          currentLength += dashSize + gapSize;
        }

        return dashedCylinders;
      }
    }

    // Set up the scene
    const scene = new THREE.Scene();

    // Set the scene background to white
    scene.background = new THREE.Color(0xffffff);

    // Set up the renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create an isometric camera
    const aspect = window.innerWidth / window.innerHeight;
    const d = 4; // Controls the zoom level
    const camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);

    // Position the camera for an isometric view
    camera.position.set(5, 5, 5);
    camera.lookAt(0, 0, 0);

    // Add a light source
    const ambientLight = new THREE.AmbientLight(0xffffff, 1);
    scene.add(ambientLight);

    // Data structure defining entities and connections
    const data = {
      entities: [
        {
          id: '1',
          name: 'Resource 1',
          position: { x: -1.5, y: 0, z: 0 },
          textureUrl: '/Azure_Public_Service_Icons/Icons/app services/10035-icon-service-App-Services.svg'
        },
        {
          id: '2',
          name: 'Resource 2',
          position: { x: 1.5, y: 0, z: 0 },
          textureUrl: '/Azure_Public_Service_Icons/Icons/compute/10023-icon-service-Kubernetes-Services.svg'
        }
      ],
      connections: [
        { from: '1', to: '2' }
      ]
    };

    // Load entities and render
    const entityObjects = {};
    const promises = data.entities.map(entityData => {
      const resource = new Resource(entityData.id, entityData.name, entityData.position, entityData.textureUrl, scene, renderer);
      entityObjects[entityData.id] = resource;
      return resource.load();
    });

    Promise.all(promises).then(() => {
      // After all textures are loaded and entities are added
      data.connections.forEach(connection => {
        const fromEntity = entityObjects[connection.from];
        const toEntity = entityObjects[connection.to];
        const dashedLine = new DashedLine(fromEntity, toEntity, scene);
        dashedLine.create();
      });

      // Render the scene
      animate();
    }).catch(err => {
      console.error('Error loading entities:', err);
    });

    // Render the scene
    function animate() {
      requestAnimationFrame(animate);
      renderer.render(scene, camera);
    }

    // Handle window resize
    window.addEventListener('resize', onWindowResize, false);
    function onWindowResize() {
      const aspect = window.innerWidth / window.innerHeight;
      camera.left = -d * aspect;
      camera.right = d * aspect;
      camera.top = d;
      camera.bottom = -d;
      camera.updateProjectionMatrix();

      renderer.setSize(window.innerWidth, window.innerHeight);
    }
  </script>
</body>
</html>
